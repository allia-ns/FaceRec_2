# -*- coding: utf-8 -*-
"""FaceRec_GUI_Streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/161qDTvXtbsxSod2WIIXgLczJBSDCXIQI
"""

# -*- coding: utf-8 -*-
"""
FaceRec_GUI_Streamlit.py
Face Recognition GUI using Streamlit
"""

import streamlit as st

# Configure page
st.set_page_config(
    page_title="Face Recognition System",
    page_icon="üé≠",
    layout="wide",
    initial_sidebar_state="expanded"
)

import os
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import io
import base64

# Import your face recognition functions
try:
    from FaceRec import load_model, recognize_face, quick_recognize
    st.success("‚úÖ FaceRec module imported successfully!")
except ImportError as e:
    st.error(f"‚ùå Error importing FaceRec: {e}")
    st.error("üí° Make sure FaceRec.py is in the same directory!")

# Custom CSS for glass purple theme
def load_css():
    st.markdown("""
    <style>
    .main {
        background: linear-gradient(135deg, #1a0d2e 0%, #2d1b3d 100%);
    }

    .stApp {
        background: linear-gradient(135deg, #1a0d2e 0%, #2d1b3d 100%);
    }

    .glass-panel {
        background: rgba(45, 27, 61, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        border: 1px solid rgba(139, 90, 150, 0.3);
        padding: 20px;
        margin: 10px 0;
    }

    .title-text {
        color: #e6d7ff;
        text-align: center;
        font-size: 2.5rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        margin-bottom: 10px;
    }

    .subtitle-text {
        color: #8b5a96;
        text-align: center;
        font-size: 1.2rem;
        font-style: italic;
        margin-bottom: 30px;
    }

    .result-box {
        background: rgba(26, 13, 46, 0.9);
        color: #e6d7ff;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #8b5a96;
        margin: 10px 0;
    }

    .success-box {
        background: rgba(76, 175, 80, 0.2);
        color: #4caf50;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #4caf50;
        margin: 10px 0;
    }

    .error-box {
        background: rgba(244, 67, 54, 0.2);
        color: #f44336;
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #f44336;
        margin: 10px 0;
    }

    .metric-card {
        background: rgba(45, 27, 61, 0.8);
        padding: 15px;
        border-radius: 10px;
        border: 1px solid rgba(139, 90, 150, 0.5);
        text-align: center;
    }

    .stButton button {
        background: linear-gradient(45deg, #6b4c7a, #8b5a96);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 10px 20px;
        font-weight: bold;
        transition: all 0.3s ease;
    }

    .stButton button:hover {
        background: linear-gradient(45deg, #8b5a96, #a067ab);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(139, 90, 150, 0.4);
    }

    .sidebar .sidebar-content {
        background: rgba(45, 27, 61, 0.9);
    }

    .uploadedFile {
        background: rgba(45, 27, 61, 0.8);
        border-radius: 10px;
        border: 1px solid rgba(139, 90, 150, 0.3);
    }
    </style>
    """, unsafe_allow_html=True)

def display_header():
    """Display the main header"""
    st.markdown('<div class="title-text">üé≠ FACE RECOGNITION SYSTEM</div>', unsafe_allow_html=True)
    st.markdown('<div class="subtitle-text">Eigenfaces & Linear Algebra Project</div>', unsafe_allow_html=True)
    st.markdown("---")

def display_disclaimer():
    """Display disclaimer about the system"""
    with st.expander("‚ö†Ô∏è System Information & Disclaimer", expanded=False):
        st.markdown("""
        **üéØ Dataset Information:**
        - Barack Obama, Ellen Page, Tom Holland, Chris Evans, Bill Gates
        - Ben Affleck, Avril Lavigne, Rihanna, Taylor Swift, Lionel Messi

        **‚ö° How it works:**
        - Uses Eigenface method with custom Linear Algebra implementation
        - Custom eigenvalue/eigenvector calculation (no library shortcuts)
        - Custom Euclidean distance calculation

        **üì∏ For best results:**
        - Use clear face images facing the camera
        - Good lighting and contrast
        - Single person in the image
        """)

def load_and_cache_model():
    """Load model with caching"""
    if 'model_loaded' not in st.session_state:
        st.session_state.model_loaded = False
        st.session_state.model_data = None

    if not st.session_state.model_loaded:
        with st.spinner("üì• Loading trained model..."):
            try:
                # Try to load model
                model_data = load_model('saved_models')

                if model_data[0] is not None:  # mean_face is not None
                    st.session_state.model_data = model_data
                    st.session_state.model_loaded = True

                    # Get model info
                    mean_face, eigenfaces, projected_train, eigenvalues, X, labels = model_data
                    unique_people = len(set(labels))

                    st.success("‚úÖ Model loaded successfully!")

                    # Display model info in sidebar
                    st.sidebar.markdown("### üìä Model Information")
                    st.sidebar.metric("Training Images", X.shape[1])
                    st.sidebar.metric("People in Dataset", unique_people)
                    st.sidebar.metric("Eigenfaces", eigenfaces.shape[1])
                    st.sidebar.metric("Image Dimensions", f"{int(np.sqrt(X.shape[0]))}√ó{int(np.sqrt(X.shape[0]))}")

                    return True
                else:
                    st.error("‚ùå Failed to load model!")
                    st.error("üí° Make sure 'saved_models' folder exists and contains trained model files")
                    return False

            except Exception as e:
                st.error(f"‚ùå Error loading model: {str(e)}")
                st.error("üí° Make sure you have run the training phase first!")
                return False

    return st.session_state.model_loaded

def display_test_image(uploaded_file):
    """Display uploaded test image"""
    if uploaded_file is not None:
        # Display image
        image = Image.open(uploaded_file)

        # Create two columns for better layout
        col1, col2 = st.columns([1, 2])

        with col1:
            st.markdown("### üì∏ Test Image")
            st.image(image, caption=f"üìÅ {uploaded_file.name}", use_column_width=True)

            # Image info
            st.markdown(f"""
            <div class="result-box">
            <strong>üìã Image Info:</strong><br>
            ‚Ä¢ Size: {image.size}<br>
            ‚Ä¢ Mode: {image.mode}<br>
            ‚Ä¢ Format: {uploaded_file.type}
            </div>
            """, unsafe_allow_html=True)

        return col2
    return None

def perform_recognition(uploaded_file, threshold=15.0):
    """Perform face recognition"""
    if not st.session_state.model_loaded:
        st.error("‚ùå Please load the model first!")
        return

    if uploaded_file is None:
        st.warning("‚ö†Ô∏è Please upload a test image first!")
        return

    # Save uploaded file temporarily
    with open("temp_test_image.jpg", "wb") as f:
        f.write(uploaded_file.getbuffer())

    try:
        with st.spinner("üîç Analyzing face..."):
            # Get model data
            mean_face, eigenfaces, projected_train, eigenvalues, X, labels = st.session_state.model_data

            # Perform recognition
            result, distance, top_matches = recognize_face(
                "temp_test_image.jpg",
                mean_face,
                eigenfaces,
                projected_train,
                X,
                labels,
                threshold=threshold,
                show_plots=False
            )

            # Display results
            if result:
                st.markdown(f"""
                <div class="success-box">
                <h3>üéâ MATCH FOUND!</h3>
                <p><strong>üë§ Identified as:</strong> {result}</p>
                <p><strong>üìè Distance:</strong> {distance:.2f}</p>
                <p><strong>üéØ Confidence:</strong> {"High" if distance < 10 else "Medium" if distance < 15 else "Low"}</p>
                </div>
                """, unsafe_allow_html=True)

                # Show top matches
                st.markdown("### üèÜ Top 3 Matches:")
                for i, (dist, label, idx) in enumerate(top_matches[:3]):
                    confidence = "üü¢ High" if dist < 10 else "üü° Medium" if dist < 15 else "üî¥ Low"
                    st.markdown(f"**{i+1}.** {label} - Distance: {dist:.2f} {confidence}")

            else:
                st.markdown(f"""
                <div class="error-box">
                <h3>üòû NO MATCH FOUND</h3>
                <p><strong>üìè Minimum Distance:</strong> {distance:.2f}</p>
                <p><strong>üéØ Threshold:</strong> {threshold:.2f}</p>
                <p>üí° Try adjusting the threshold or use a different image</p>
                </div>
                """, unsafe_allow_html=True)

                # Show closest matches anyway
                st.markdown("### üîç Closest Matches (for reference):")
                for i, (dist, label, idx) in enumerate(top_matches[:3]):
                    st.markdown(f"**{i+1}.** {label} - Distance: {dist:.2f}")

        # Cleanup
        if os.path.exists("temp_test_image.jpg"):
            os.remove("temp_test_image.jpg")

    except Exception as e:
        st.error(f"‚ùå Error during recognition: {str(e)}")
        # Cleanup on error
        if os.path.exists("temp_test_image.jpg"):
            os.remove("temp_test_image.jpg")

def display_distance_analysis(uploaded_file, threshold=15.0):
    """Display distance analysis and visualization"""
    if not st.session_state.model_loaded or uploaded_file is None:
        return

    # Save uploaded file temporarily
    with open("temp_test_image.jpg", "wb") as f:
        f.write(uploaded_file.getbuffer())

    try:
        # Get model data
        mean_face, eigenfaces, projected_train, eigenvalues, X, labels = st.session_state.model_data

        # Perform recognition to get distances
        result, distance, top_matches = recognize_face(
            "temp_test_image.jpg",
            mean_face,
            eigenfaces,
            projected_train,
            X,
            labels,
            threshold=threshold,
            show_plots=False
        )

        # Extract all distances
        distances = [match[0] for match in top_matches]

        # Create distance histogram
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.hist(distances, bins=20, alpha=0.7, color='#8b5a96', edgecolor='#e6d7ff')
        ax.axvline(x=distance, color='#ff4444', linestyle='--', linewidth=2,
                  label=f'Best Match: {distance:.2f}')
        ax.axvline(x=threshold, color='#44ff44', linestyle='--', linewidth=2,
                  label=f'Threshold: {threshold:.2f}')

        ax.set_xlabel('Euclidean Distance', color='#e6d7ff')
        ax.set_ylabel('Frequency', color='#e6d7ff')
        ax.set_title('Distance Distribution Analysis', color='#e6d7ff', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)

        # Style the plot for dark theme
        ax.set_facecolor('#1a0d2e')
        fig.patch.set_facecolor('#1a0d2e')
        ax.tick_params(colors='#e6d7ff')
        ax.spines['bottom'].set_color('#e6d7ff')
        ax.spines['top'].set_color('#e6d7ff')
        ax.spines['right'].set_color('#e6d7ff')
        ax.spines['left'].set_color('#e6d7ff')

        st.pyplot(fig)
        plt.close(fig)

        # Distance statistics
        st.markdown("### üìä Distance Statistics")
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("Minimum Distance", f"{min(distances):.2f}")
        with col2:
            st.metric("Average Distance", f"{np.mean(distances):.2f}")
        with col3:
            st.metric("Maximum Distance", f"{max(distances):.2f}")
        with col4:
            st.metric("Standard Deviation", f"{np.std(distances):.2f}")

        # Cleanup
        if os.path.exists("temp_test_image.jpg"):
            os.remove("temp_test_image.jpg")

    except Exception as e:
        st.error(f"‚ùå Error in distance analysis: {str(e)}")
        if os.path.exists("temp_test_image.jpg"):
            os.remove("temp_test_image.jpg")

def main():
    # Load custom CSS
    load_css()

    # Display header
    display_header()

    # Display disclaimer
    display_disclaimer()

    # Sidebar controls
    st.sidebar.markdown("## üéõÔ∏è Control Panel")

    # Model loading
    if st.sidebar.button("üöÄ Load Model", type="primary"):
        if load_and_cache_model():
            st.rerun()

    # Check if model is loaded
    model_loaded = load_and_cache_model()

    if not model_loaded:
        st.warning("‚ö†Ô∏è Please load the model first using the sidebar button!")
        return

    # Threshold adjustment
    st.sidebar.markdown("### ‚öôÔ∏è Settings")
    threshold = st.sidebar.slider(
        "üéØ Recognition Threshold",
        min_value=5.0,
        max_value=30.0,
        value=15.0,
        step=0.5,
        help="Lower values = stricter matching"
    )

    # File upload
    st.markdown("### üìÅ Upload Test Image")
    uploaded_file = st.file_uploader(
        "Choose an image file",
        type=['jpg', 'jpeg', 'png', 'bmp'],
        help="Upload a clear face image for recognition"
    )

    if uploaded_file is not None:
        # Display image and get column for results
        result_col = display_test_image(uploaded_file)

        # Recognition button and results
        if result_col:
            with result_col:
                st.markdown("### üîç Recognition Results")

                if st.button("üéØ Recognize Face", type="primary"):
                    perform_recognition(uploaded_file, threshold)

                # Advanced analysis
                if st.button("üìä Show Distance Analysis"):
                    st.markdown("### üìà Distance Analysis")
                    display_distance_analysis(uploaded_file, threshold)

    # Footer
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: #8b5a96; font-style: italic;'>
    üé≠ Face Recognition System | Eigenfaces & Linear Algebra Project<br>
    Built with ‚ù§Ô∏è using Streamlit & Custom Eigenface Implementation
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
# -*- coding: utf-8 -*-
"""FaceRec.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FlMrrf78bAH9J1R7uMrDoWPLTFRqFQuR
"""

# -*- coding: utf-8 -*-
"""
FaceRec.py - Sistem Pengenalan Wajah menggunakan Eigenface
Implementasi custom eigenvalue/eigenvector dan euclidean distance
Tugas Aljabar Linear - Universitas Sebelas Maret
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import os
from PIL import Image
import json
import zipfile
import shutil

# ===== BAGIAN 1: FUNGSI UTILITAS DAN LOAD DATASET =====

def extract_dataset_if_needed(zip_path, extract_to):
    """
    Ekstrak dataset zip jika folder belum ada
    """
    if not os.path.exists(extract_to) and os.path.exists(zip_path):
        print(f"📦 Mengekstrak {zip_path}...")

        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall('.')

        # Cek struktur folder bersarang
        extracted_items = os.listdir('.')
        for item in extracted_items:
            if os.path.isdir(item) and item == extract_to:
                inner_path = os.path.join(item, extract_to)
                if os.path.exists(inner_path):
                    print(f"🔧 Memperbaiki struktur folder bersarang...")
                    temp_folder = f"{extract_to}_temp"
                    shutil.move(inner_path, temp_folder)
                    shutil.rmtree(item)
                    shutil.move(temp_folder, extract_to)
                    print(f"✅ Struktur folder diperbaiki!")
                    break

        if os.path.exists(extract_to):
            persons = os.listdir(extract_to)
            print(f"📂 Ditemukan orang: {persons}")
    elif os.path.exists(extract_to):
        print(f"📁 Folder dataset sudah ada.")
    else:
        print(f"❌ Tidak ditemukan {zip_path} atau {extract_to}!")

def load_images_from_folder(folder_path, image_size=(100, 100)):
    """
    Load gambar dari folder dan return dalam format matriks
    """
    images = []
    labels = []

    # Cek folder, jika tidak ada coba ekstrak dari zip
    zip_path = f"{folder_path}.zip"
    extract_dataset_if_needed(zip_path, folder_path)

    if not os.path.exists(folder_path):
        print(f"❌ Folder dataset {folder_path} tidak ditemukan!")
        return None, None

    persons = sorted(os.listdir(folder_path))
    print(f"📁 Ditemukan {len(persons)} orang: {persons}")

    for person in persons:
        person_folder = os.path.join(folder_path, person)
        if not os.path.isdir(person_folder):
            continue

        files = [f for f in os.listdir(person_folder) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
        print(f"👤 {person}: {len(files)} gambar")

        for filename in sorted(files):
            img_path = os.path.join(person_folder, filename)
            try:
                img = Image.open(img_path).convert('L')  # Grayscale
                img = img.resize(image_size)  # Resize
                img_np = np.asarray(img, dtype=np.float32) / 255.0  # Normalisasi 0-1
                images.append(img_np.flatten())  # Jadikan vektor 1D
                labels.append(person)

            except Exception as e:
                print(f"⚠️ Error loading {img_path}: {e}")
                continue

    X = np.array(images).T  # Shape: (pixels, samples)
    print(f"✅ Total dimuat: {len(labels)} gambar")
    print(f"📊 Bentuk matriks: {X.shape}")

    return X, labels

def show_image(vec, shape=(100, 100), title="Gambar"):
    """
    Tampilkan gambar dari vektor yang di-flatten
    """
    plt.figure(figsize=(4, 4))
    plt.imshow(vec.reshape(shape), cmap='gray')
    plt.title(title)
    plt.axis('off')
    plt.show()

# ===== BAGIAN 2: IMPLEMENTASI CUSTOM EIGENVALUE/EIGENVECTOR =====

def power_iteration_optimized(A, max_iter=200, tol=1e-4):
    """
    Power iteration yang dioptimasi untuk konvergensi lebih cepat
    Implementasi sendiri tanpa menggunakan library numpy shortcuts
    """
    n = A.shape[0]

    # Inisialisasi yang lebih baik: gunakan baris dengan norm terbesar
    row_norms = np.zeros(n)
    for i in range(n):
        for j in range(n):
            row_norms[i] += A[i, j] ** 2

    max_row = 0
    max_norm = row_norms[0]
    for i in range(1, n):
        if row_norms[i] > max_norm:
            max_norm = row_norms[i]
            max_row = i

    # Mulai dengan baris yang paling "penting"
    b = A[max_row, :].copy()

    # Normalisasi manual
    norm = 0
    for i in range(n):
        norm += b[i] ** 2
    norm = norm ** 0.5

    if norm > 1e-10:
        for i in range(n):
            b[i] = b[i] / norm

    prev_eigenvalue = 0

    for iteration in range(max_iter):
        # Perkalian matriks-vektor manual: A @ b
        Ab = np.zeros(n)
        for i in range(n):
            for j in range(n):
                Ab[i] += A[i, j] * b[j]

        # Hitung eigenvalue (Rayleigh quotient)
        eigenvalue = 0
        for i in range(n):
            eigenvalue += b[i] * Ab[i]

        # Normalisasi Ab
        norm = 0
        for i in range(n):
            norm += Ab[i] ** 2
        norm = norm ** 0.5

        if norm < tol:
            break

        b_new = np.zeros(n)
        for i in range(n):
            b_new[i] = Ab[i] / norm

        # Cek konvergensi berdasarkan perubahan eigenvalue
        eigenvalue_change = abs(eigenvalue - prev_eigenvalue)
        if eigenvalue_change < tol and iteration > 5:
            break

        b = b_new
        prev_eigenvalue = eigenvalue

    return eigenvalue, b

def compute_top_eigenfaces(A, k=30):
    """
    Hitung eigenface teratas menggunakan implementasi custom
    Menggunakan trik matriks kovarian kecil untuk efisiensi: C = A.T @ A
    """
    print(f"🧮 Menghitung {k} eigenface teratas...")

    # Trik matriks kovarian kecil: C = A.T @ A
    C_small = A.T @ A
    print(f"📊 Bentuk matriks kovarian: {C_small.shape}")

    eigenvalues = []
    eigenvectors_small = []

    # Buat salinan kerja
    C_work = C_small.copy()

    # Hitung trace asli untuk deflasi yang lebih baik
    original_trace = 0
    for i in range(C_work.shape[0]):
        original_trace += C_work[i, i]

    for i in range(min(k, C_small.shape[0])):
        print(f"⚡ Menghitung eigenface {i+1}/{k}")

        # Dapatkan eigenvalue/eigenvector terbesar
        eigenval, eigenvec = power_iteration_optimized(C_work, max_iter=150, tol=1e-4)

        # Hentikan lebih awal jika eigenvalue terlalu kecil
        if eigenval < 1e-8:
            print(f"🛑 Berhenti lebih awal - eigenvalue terlalu kecil: {eigenval:.2e}")
            break

        eigenvalues.append(eigenval)
        eigenvectors_small.append(eigenvec.copy())

        # Deflasi yang lebih baik dengan pengecekan stabilitas
        # C_new = C - eigenval * eigenvec @ eigenvec.T
        outer_product = np.zeros((C_work.shape[0], C_work.shape[1]))
        for row in range(C_work.shape[0]):
            for col in range(C_work.shape[1]):
                outer_product[row, col] = eigenvec[row] * eigenvec[col]

        # Deflasi dengan faktor skala untuk menjaga stabilitas
        deflation_scale = min(1.0, eigenval / (original_trace / C_work.shape[0]))

        for row in range(C_work.shape[0]):
            for col in range(C_work.shape[1]):
                C_work[row, col] -= deflation_scale * eigenval * outer_product[row, col]

        # Cek trace yang tersisa
        remaining_trace = 0
        for j in range(C_work.shape[0]):
            remaining_trace += C_work[j, j]

        if remaining_trace < 1e-6:
            print(f"🛑 Berhenti lebih awal - matriks habis setelah {i+1} eigenface")
            break

        # Info progres
        if i < 5 or i % 5 == 4:
            print(f"   → Eigenvalue: {eigenval:.2e}, Trace tersisa: {remaining_trace:.2e}")

    # Konversi ke numpy arrays
    eigenvalues = np.array(eigenvalues)
    eigenvectors_small = np.array(eigenvectors_small).T

    # Konversi ke eigenface sebenarnya: U = A @ eigenvectors_small
    eigenfaces = A @ eigenvectors_small

    # Normalisasi eigenface (lebih efisien)
    for i in range(eigenfaces.shape[1]):
        norm = 0
        for j in range(eigenfaces.shape[0]):
            norm += eigenfaces[j, i] ** 2
        norm = norm ** 0.5

        if norm > 1e-10:
            for j in range(eigenfaces.shape[0]):
                eigenfaces[j, i] /= norm

    print(f"✅ Berhasil menghitung {len(eigenvalues)} eigenface")
    return eigenfaces, eigenvalues

# ===== BAGIAN 3: IMPLEMENTASI CUSTOM EUCLIDEAN DISTANCE =====

def euclidean_distance(vec1, vec2):
    """
    Implementasi custom euclidean distance dengan perhitungan manual!
    """
    if len(vec1) != len(vec2):
        raise ValueError("Vektor harus memiliki panjang yang sama")

    distance = 0
    for i in range(len(vec1)):
        diff = vec1[i] - vec2[i]
        distance += diff * diff

    return distance ** 0.5

# ===== BAGIAN 4: FASE TRAINING =====

def train_eigenface_model(dataset_path, k_eigenfaces=25):
    """
    Training model eigenface
    Returns: mean_face, eigenfaces, projected_train, eigenvalues, X, labels
    """
    print("🚀 Memulai training...")

    # Load dataset
    X, labels = load_images_from_folder(dataset_path)
    if X is None:
        return None, None, None, None, None, None

    # Langkah 1: Hitung mean face
    print("📊 Menghitung mean face...")
    mean_face = np.mean(X, axis=1, keepdims=True)

    # Langkah 2: Center data (kurangi mean)
    print("🎯 Centering data...")
    A = X - mean_face

    # Langkah 3: Hitung eigenface
    eigenfaces, eigenvalues = compute_top_eigenfaces(A, k=k_eigenfaces)

    # Langkah 4: Proyeksikan data training ke ruang eigenface
    print("🎲 Memproyeksikan data training...")
    projected_train = eigenfaces.T @ A

    print("✅ Training selesai!")
    print(f"📊 Menggunakan {eigenfaces.shape[1]} eigenface")
    print(f"📊 Bentuk data training di eigenspace: {projected_train.shape}")

    return mean_face, eigenfaces, projected_train, eigenvalues, X, labels

# ===== BAGIAN 5: FASE TESTING/RECOGNITION =====

def recognize_face(test_image_path, mean_face, eigenfaces, projected_train, X, labels, threshold=15.0, show_plots=True):
    """
    Kenali wajah dari gambar test
    """
    print(f"🔍 Mengenali wajah: {test_image_path}")

    # Load dan preprocess gambar test
    try:
        img = Image.open(test_image_path).convert('L')
        img = img.resize((100, 100))
        img_np = np.asarray(img, dtype=np.float32) / 255.0
        img_vec = img_np.flatten().reshape(-1, 1)

        if show_plots:
            show_image(img_vec.flatten(), title="Gambar Test")

    except Exception as e:
        print(f"❌ Error loading gambar test: {e}")
        return None, None, None

    # Preprocess: center gambar
    img_centered = img_vec - mean_face

    # Proyeksi ke ruang eigenface
    img_projected = eigenfaces.T @ img_centered
    img_projected = img_projected.flatten()

    # Cari kecocokan terdekat
    min_distance = float('inf')
    best_match_idx = -1
    distances = []

    for i in range(projected_train.shape[1]):
        train_proj = projected_train[:, i]
        distance = euclidean_distance(img_projected, train_proj)
        distances.append(distance)

        if distance < min_distance:
            min_distance = distance
            best_match_idx = i

    # Dapatkan top 3 kecocokan
    distance_pairs = [(distances[i], labels[i], i) for i in range(len(distances))]
    distance_pairs.sort(key=lambda x: x[0])
    top_3 = distance_pairs[:3]

    # Analisis hasil
    print(f"🎯 Hasil:")
    print(f"→ Jarak minimum: {min_distance:.2f}")
    print(f"→ Jarak rata-rata: {np.mean(distances):.2f}")
    print(f"→ Threshold: {threshold:.2f}")

    print(f"\n🏆 Top 3 kecocokan:")
    for i, (dist, label, idx) in enumerate(top_3):
        print(f"  {i+1}. {label} (jarak: {dist:.2f})")

    # Plot distribusi jarak
    if show_plots:
        plt.figure(figsize=(10, 4))
        plt.hist(distances, bins=20, alpha=0.7, color='blue')
        plt.axvline(x=min_distance, color='red', linestyle='--',
                    label=f'Kecocokan terbaik: {min_distance:.2f}')
        plt.axvline(x=threshold, color='orange', linestyle='--',
                    label=f'Threshold: {threshold:.2f}')
        plt.xlabel('Jarak Euclidean')
        plt.ylabel('Frekuensi')
        plt.title('Distribusi Jarak')
        plt.legend()
        plt.grid(True)
        plt.show()

    # Keputusan
    if min_distance <= threshold:
        result = labels[best_match_idx]
        print(f"✅ KECOCOKAN DITEMUKAN: {result}")
        if show_plots:
            show_image(X[:, best_match_idx], title=f"Cocok: {result}")
        return result, min_distance, top_3
    else:
        print(f"❌ TIDAK ADA KECOCOKAN (jarak > threshold)")
        return None, min_distance, top_3

# ===== BAGIAN 6: SAVE/LOAD MODEL =====

def save_model(mean_face, eigenfaces, projected_train, eigenvalues, X, labels, save_path='saved_models'):
    """
    Simpan model yang sudah ditraining
    """
    print("💾 Menyimpan model...")

    os.makedirs(save_path, exist_ok=True)

    # Simpan numpy arrays
    np.save(f'{save_path}/X.npy', X)
    np.save(f'{save_path}/mean_face.npy', mean_face)
    np.save(f'{save_path}/eigenfaces.npy', eigenfaces)
    np.save(f'{save_path}/projected_train.npy', projected_train)
    np.save(f'{save_path}/eigenvalues.npy', eigenvalues)

    # Simpan labels
    with open(f'{save_path}/labels.json', 'w') as f:
        json.dump(labels, f)

    print("✅ Model berhasil disimpan!")

def load_model(model_path='saved_models'):
    """
    Load model yang sudah ditraining - TANPA PERLU TRAINING ULANG!
    """
    print("📥 Loading model yang sudah ditraining...")

    try:
        # Load semua array yang disimpan
        X = np.load(f'{model_path}/X.npy')
        mean_face = np.load(f'{model_path}/mean_face.npy')
        eigenfaces = np.load(f'{model_path}/eigenfaces.npy')
        projected_train = np.load(f'{model_path}/projected_train.npy')
        eigenvalues = np.load(f'{model_path}/eigenvalues.npy')

        # Load labels
        with open(f'{model_path}/labels.json', 'r') as f:
            labels = json.load(f)

        print("✅ Model berhasil dimuat!")
        print(f"📊 Data training: {X.shape}")
        print(f"📊 Eigenface: {eigenfaces.shape}")
        print(f"📊 Jumlah orang: {len(set(labels))}")

        return mean_face, eigenfaces, projected_train, eigenvalues, X, labels

    except Exception as e:
        print(f"❌ Error loading model: {e}")
        print("💡 Pastikan sudah menjalankan training dan menyimpan model!")
        return None, None, None, None, None, None

# ===== BAGIAN 7: FUNGSI UTAMA UNTUK TESTING =====

def quick_recognize(test_image_path, mean_face, eigenfaces, projected_train, X, labels, threshold=15.0):
    """
    Pengenalan wajah cepat menggunakan model yang sudah dimuat
    """
    return recognize_face(test_image_path, mean_face, eigenfaces, projected_train, X, labels, threshold, show_plots=False)

def visualize_results(mean_face, eigenfaces, eigenvalues):
    """
    Visualisasi hasil training
    """
    # Tampilkan mean face
    show_image(mean_face.flatten(), title="Mean Face")

    # Tampilkan beberapa eigenface
    fig, axes = plt.subplots(2, 3, figsize=(12, 8))
    axes = axes.flatten()

    for i in range(6):
        if i < eigenfaces.shape[1]:
            eigenface = eigenfaces[:, i]
            # Normalisasi untuk display
            eigenface_display = (eigenface - eigenface.min()) / (eigenface.max() - eigenface.min())
            axes[i].imshow(eigenface_display.reshape(100, 100), cmap='gray')
            axes[i].set_title(f'Eigenface {i+1}')
            axes[i].axis('off')
        else:
            axes[i].axis('off')

    plt.tight_layout()
    plt.show()

    # Tampilkan distribusi eigenvalue
    plt.figure(figsize=(10, 4))
    plt.plot(eigenvalues, 'bo-')
    plt.title('Distribusi Eigenvalue')
    plt.xlabel('Index Eigenface')
    plt.ylabel('Eigenvalue')
    plt.grid(True)
    plt.show()